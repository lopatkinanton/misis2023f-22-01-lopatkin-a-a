## 1. Паттерны проектирования
**Паттерны проектирования** - это общепринятые способы или шаблоны решения часто встречающихся проблем в определенном контексте проектирования ПО, формально описанные лучшие практики. 

Паттерн проектирования фиксирует и описывает ключевые аспекты структуры общего решения, которые и позволяют применить его для создания повторно используемого дизайна. Он выделяет участвующие классы и экземпляры, их роли и отношения, а также распределение обязанностей. 

Так как паттерны описывают не конкретное решение, а скорее некий путь к нему, то выбор подходящего паттерна - это творческая задача, для которой зачастую нет правильного ответа.
## 2. Порождающие паттерны проектирования
**Порождающие паттерны проектирования** предназначены для создания объектов, позволяя системе оставаться независимой как от самого процесса порождения, так и от типов порождаемых объектов. 

Если в коде используются многочисленные конкретные классы, то с заменой, удалением или добавлением новых конкретных классов код придется сильно изменять. Абстрагируя создание конкретных классов, порождающие паттерны делают систему более гибкой и устойчивой к изменениям.
## 3. Абстрактная фабрика
Паттерн абстрактная фабрика предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов без зависимости от их конкретных классов.
## 3.1. Критерии применимости
1. система не должна зависеть от того, как создаются, компонуются и представляются входящие в нее объекты; 
2. система должна настраиваться одним из семейств объектов; 
3. входящие в семейство взаимосвязанные объекты спроектированы для совместной работы, и выполнение этого ограничения гарантируется;  
4. вы хотите предоставить библиотеку объектов, раскрывая только их интерфейсы, но не реализацию
5. не планируется расширение семейства объектов
## 3.2. Структура
<p align="center">
<img src="structure.png>
</p>
**AbstractFactory** объявляет интерфейс для операций, создающих абстрактные объекты-продукты;
**ConcreteFactory** реализует операции, создающие конкретные объекты-продукты, относящиеся к одному семейству;
**AbstractProduct** объявляет интерфейс для типа объекта-продукта;
**ConcreteProduct** определяет объект-продукт, создаваемый соответствующей конкретной фабрикой, реализует интерфейс *AbstractProduct*;
**Client** пользуется исключительно интерфейсами, которые объявлены в классах *AbstractFactory* и *AbstractProduct*.

## 3.2. Пример использования 
*Код для данного примера лежит в личном репозитории на gihub в папке /docs.*

Рассмотрим инструментальную программу для создания пользовательского интерфейса, поддерживающего разные стандарты оформления, например Motif и Presentation Manager (PM). Оформление определяет визуальное представление и поведение элементов пользовательского интерфейса («виджетов») — полос прокрутки, окон и кнопок. 
Чтобы приложение можно было перенести на другой стандарт, в нем не должен быть жестко закодировано оформление виджетов. Если создание экземпляров классов для конкретного оформления разбросано по всему приложению, то изменить оформление впоследствии будет нелегко. 
<p align="center">
<img src="example.png>
</p>

Для решения этой проблемы создадим абстрактную фабрику WidgetFactory, объявляющую интерфейс для создания всех основных видов виджетов. Есть также абстрактные классы Window, ScrollBar и т.д. для каждого отдельного вида виджетов, и их конкретные подклассы, реализующие виджеты с определенным оформлением. 
В интерфейсе WidgetFactory имеется операция, возвращающая новый объект-виджет для каждого абстрактного класса виджетов. Клиенты вызывают эти операции для получения экземпляров виджетов, но при этом ничего не знают о том, какие именно классы используются. Таким образом, клиенты остаются независимыми от выбранного стандарта оформления. 
Для каждого стандарта оформления существует определенный подкласс WidgetFactory. Каждый такой подкласс реализует операции, необходимые для создания соответствующего стандарту виджета. Например, операция CreateScrollBar в классе MotifWidgetFactory создает экземпляр и возвращает полосу прокрутки в стандарте Motif, тогда как соответствующая операция в классе PMWidgetFactory возвращает полосу прокрутки в стандарте Presentation Manager. Клиенты создают виджеты, пользуясь исключительно интерфейсом WidgetFactory, и им ничего не известно о классах, реализующих виджеты для конкретного стандарта. Другими словами, клиенты должны лишь придерживаться интерфейса, определенного абстрактным, а не конкретным классом. 
Класс WidgetFactory также устанавливает зависимости между конкретными классами виджетов. Полоса прокрутки для Motif должна использоваться с кнопкой и текстовым полем Motif, и это ограничение поддерживается автоматически как следствие использования класса MotifWidgetFactory.
## 3.3. Реализация и связь с другими паттернами
Конкретная фабрика часто описывается паттерном Singleton. Как правило, приложению нужен только один экземпляр класса ConcreteFactory на каждое семейство продуктов. 

Класс AbstractFactory объявляет только интерфейс для создания продуктов. Фактическое их создание — дело подклассов ConcreteProduct. Чаще всего для этой цели определяется фабричный метод для каждого продукта. Конкретная фабрика определяет свои продукты путем замещения фабричного метода для каждого из них. Хотя такая реализация проста, она требует создавать новый подкласс конкретной фабрики для каждого семейства продуктов, даже если они почти ничем не отличаются. 

Если семейств продуктов может быть много, то конкретную фабрику удастся реализовать с помощью паттерна прототип. В этом случае она инициализируется экземпляром-прототипом каждого продукта в семействе и создает новый продукт путем клонирования этого прототипа. Подход на основе прототипов устраняет необходимость создавать новый класс конкретной фабрики для каждого нового семейства продуктов.

Класс AbstractFactory обычно определяет разные операции для всех видов изготавливаемых продуктов. Виды продуктов кодируются в сигнатуре операции. Для добавления нового вида продуктов нужно изменить интерфейс класса AbstractFactory и всех зависящих от него классов. 

Более гибкий, но менее безопасный способ — добавить параметр к операциям, создающим объекты. Данный параметр определяет вид создаваемого объекта. Это может быть идентификатор класса, целое число, строка или что-то еще, однозначно описывающее вид продукта. При таком подходе классу AbstractFactory нужна только одна операция Make с параметром, задающим тип создаваемого объекта. Воспользоваться таким вариантом в статически типизированном C++ можно только в том случае, если у всех объектов имеется общий абстрактный базовый класс или если объекты-продукты могут быть безопасно приведены к корректному типу клиентом, который их запросил. Но даже если приведение типов не нужно, остается принципиальная проблема: все продукты возвращаются клиенту одним и тем же абстрактным интерфейсом с уже определенным типом возвращаемого значения. Клиент не может ни различить классы продуктов, ни сделать какие-нибудь предположения о них. Если клиенту нужно выполнить операцию, зависящую от подкласса, то она будет недоступна через абстрактный интерфейс. Здесь мы имеем классический пример компромисса между высокой степенью гибкости и расширяемостью интерфейса.

## 3.4. Результаты 
Паттерн абстрактная фабрика: 
- изолирует конкретные классы. Клиенты манипулируют экземплярами через их абстрактные интерфейсы. Имена изготавливаемых классов известны только конкретной фабрике, в коде клиента они не упоминаются;  

- упрощает замену семейств продуктов. Класс конкретной фабрики появляется в приложении только один раз: при создании экземпляра. Это облегчает замену используемой приложением конкретной фабрики. Приложение может изменить конфигурацию продуктов, просто подставив новую конкретную фабрику. Поскольку абстрактная фабрика создает все семейство продуктов, то и заменяется сразу все семейство.

- гарантирует сочетаемость продуктов. Если продукты некоторого семейства спроектированы для совместного использования, то важно, чтобы в каждый момент времени приложение работало только с продуктами единственного семейства. Класс AbstractFactory позволяет легко соблюсти это ограничение;

- не упрощает задачу поддержки нового вида продуктов.  Для поддержки новых продуктов необходимо расширить интерфейс фабрики, то есть изменить класс AbstractFactory и все его подклассы. 

##### Источники
1. Гамма Э., Хелм Р., Джонсон Р., Влиссидес Дж. Паттерны объектно-ориентированного проектирования. 
2. Фримен Э., Робсон Э., Сьерра К., Бейтс Б. Head First. Паттерны проектирования.